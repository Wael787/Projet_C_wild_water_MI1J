#!/bin/bash

# Vérification des Paramètres
if [ $# -lt 2 ]; then
    echo "Usage :"
    echo "  $0 <fichier.dat> histo {max|src|real|maxC|srcC|reelC}"
    echo "  $0 <fichier.dat> leaks {id usine}"
    exit 1
fi

# Arguments d'entrée
program=$0
dirname=$(dirname "$program")
datafile="$dirname/dat/$1"
action=$2

start_time=$(date +%s)
trap 'end_time=$(date +%s); echo -e "\nDurée totale du script : $((end_time - start_time)) s"' EXIT

# Controle existence du fichier de données
if [ ! -f "$datafile" ]; then
    echo "Erreur : fichier $datafile introuvable"
    exit 1
fi

mkdir -p "$dirname/csv"
mkdir -p "$dirname/bin"

compile() {
    local prog_name=$1
    if [ ! -x "$dirname/bin/$prog_name" ]; then
        echo "Attention: binaire $dirname/bin/$prog_name absent => compilation via Makefile..."
        make -C "$dirname" "$prog_name"
        retour=$?
        if [ $retour -ne 0 ]; then
            echo "Erreur : la compilation a échoué."
            exit 1
        fi
    fi
}

# L'action : histo
if [ "$action" = "histo" ]; then
    if [ $# -ne 3 ]; then
        echo "Usage: $0 <fichier.dat> histo {mode}"
        exit 1
    fi

    mode=$3
    csvfile="$dirname/csv/histo_$mode.csv"

    # traitement sur le shell (max, src, real)
    if [ "$mode" = "max" ] || [ "$mode" = "src" ] || [ "$mode" = "real" ]; then
        echo "Traitement via Shell/AWK ($mode)..."
        # Logique de calcul via AWK (simplifiée pour l'exemple)
        if [ "$mode" = "max" ]; then
            awk -F';' '$1=="-" && $2!="-" && $3=="-" && $4!="-" {print $2";"$4}' "$datafile" | sort -t';' -k2,2nr > "$csvfile.tmp"
        elif [ "$mode" = "src" ]; then
            awk -F';' '$1=="-" && $2!="-" && $3!="-" && $4!="-" {sum[$3]+=$4} END {for (k in sum) print k";"sum[k]}' "$datafile" | sort -t';' -k2,2nr > "$csvfile.tmp"
        else
            awk -F';' '$1=="-" && $2!="-" && $3!="-" && $4!="-" {res=$4*(100-$5)/100; sum[$3]+=res} END {for (k in sum) print k";"sum[k]}' "$datafile" | sort -t';' -k2,2nr > "$csvfile.tmp"
        fi

    # traitement sur le C (maxC, srcC, reelC) 
    elif [ "$mode" = "maxC" ] || [ "$mode" = "srcC" ] || [ "$mode" = "reelC" ]; then
        echo "Traitement via Programme C/AVL ($mode)..."
        compile "histo"
        "$dirname/bin/histo" "$datafile" "$csvfile.tmp.raw" "$mode"
        retour=$?
        if [ $retour -ne 0 ]; then
            echo "Erreur : Le programme histo a échoué."
            exit 1
        fi
        
        # Si le fichier n'existe pas, le créer
        if [ ! -f "$csvfile.tmp.raw" ]; then
            echo "identifier;volume" > "$csvfile.tmp"
        else
            # Supprimer l'en-tête et trier par volume décroissant
            tail -n +2 "$csvfile.tmp.raw" | sort -t';' -k2,2nr > "$csvfile.tmp"
            rm -f "$csvfile.tmp.raw"
        fi
    else
        echo "Mode inconnu"; exit 1
    fi

    # Compter le nombre total d'entrées
    total_entries=$(wc -l < "$csvfile.tmp")
    echo "Nombre total d'entrées : $total_entries"
    
    # top 10 max et top 50 min
    echo "Génération des classements dans $csvfile..."
    
    echo "    TOP 10 PLUS GRANDS VOLUMES" > "$csvfile"
    echo "identifier;volume" >> "$csvfile"
    head -n 10 "$csvfile.tmp" >> "$csvfile"
    
    echo "" >> "$csvfile"
    echo "    TOP 50 PLUS PETITS VOLUMES" >> "$csvfile"
    echo "identifier;volume" >> "$csvfile"
    tail -n 50 "$csvfile.tmp" | sort -t';' -k2,2n >> "$csvfile"

    # GNUPLOT - 2 graphiques
    if command -v gnuplot >/dev/null 2>&1; then
        echo "Génération des graphiques..."
        
        # Graphique 1: Top 10 plus grands volumes
        image_top10="$dirname/csv/histo_${mode}_top10.png"
        gnuplot <<EOF
            set terminal pngcairo size 1200,700 font "Arial,12"
            set output "$image_top10"
            set datafile separator ";"
            set style fill solid
            set boxwidth 0.6
            set xtics rotate by -45
            set title "Top 10 - Plus Grands Volumes ($mode)" font "Arial,16"
            set ylabel "Volume (k.m³/an)" font "Arial,12"
            set grid ytics
            set key off
            plot "< head -n 10 '$csvfile.tmp'" using 2:xtic(1) with boxes lc rgb "#9b59b6" title "Volume"
EOF
        echo "Image générée : $image_top10"
        
        # Graphique 2: Top 50 plus petits volumes
        image_top50="$dirname/csv/histo_${mode}_top50.png"
        gnuplot <<EOF
            set terminal pngcairo size 1800,900 font "Arial,8"
            set output "$image_top50"
            set datafile separator ";"
            set style fill solid
            set boxwidth 0.5
            set xtics rotate by -90 font "Arial,7"
            set title "Top 50 - Plus Petits Volumes ($mode)" font "Arial,16"
            set ylabel "Volume (k.m³/an)" font "Arial,12"
            set grid ytics
            set key off
            set bmargin 8
            plot "< tail -n 50 '$csvfile.tmp' | sort -t';' -k2,2n" using 2:xtic(1) with boxes lc rgb "#3498db" title "Volume"
EOF
        echo "Image générée : $image_top50"
    fi

    # Affichage dans le terminal
    echo ""
    echo "========================================"
    echo "       TOP 10 PLUS GRANDS VOLUMES"
    echo "========================================"
    echo "identifier;volume"
    head -n 10 "$csvfile.tmp"
    
    echo ""
    echo "========================================"
    echo "       TOP 50 PLUS PETITS VOLUMES"
    echo "========================================"
    echo "identifier;volume"
    tail -n 50 "$csvfile.tmp" | sort -t';' -k2,2n
    
    rm -f "$csvfile.tmp"
    
    echo ""
    echo "Fichier CSV généré : $csvfile"

# Action = leaks 
elif [ "$action" = "leaks" ]; then
    # Vérification qu'on a bien l'identifiant de l'usine en 3ème argument
    if [ $# -lt 3 ]; then
        echo "Erreur : L'action 'leaks' nécessite un identifiant d'usine."
        echo "Usage : $0 <fichier.dat> leaks \"Facility complex #ID\""
        exit 1
    fi

    usine_cible="$3"
    # Nettoyage du nom pour le fichier (on remplace espaces et # par des underscores)
    usine_clean=$(echo "$usine_cible" | tr ' #' '__')
    csvfile="$dirname/csv/leaks_$usine_clean.csv"

    echo "Analyse des fuites pour l'usine : $usine_cible"
    
    # Appel de la fonction de compilation pour leaks.c
    compile "leaks"

    # Exécution du programme C
    "$dirname/bin/leaks" "$datafile" "$csvfile" "$usine_cible"
    retour=$?

    if [ $retour -ne 0 ]; then
        echo "Erreur : Le programme leaks a échoué (Code retour: $retour)."
        exit 1
    fi

    # Affichage du résultat
    if [ -f "$csvfile" ]; then
        echo "Fichier de fuites généré : $csvfile"
        echo "--- Détails des fuites par source ---"
        cat "$csvfile"
    else
        echo "Erreur : Le fichier $csvfile n'a pas été créé. Vérifiez si l'identifiant d'usine existe dans le fichier .dat"
    fi
else
    echo "Action inconnue: $action"
    echo "Actions valides: histo, leaks"
    exit 1
fi
